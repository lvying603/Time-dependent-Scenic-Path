package greedLS;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


/**
 * Given a connected directed graph, find all paths between any two input points.
 */
public class GraphFindAllPaths{
	
	GreedLS greedLS = new GreedLS();
	private ArrayList<Pair<Integer, List<Integer>>> path = new ArrayList<Pair<Integer, List<Integer>>>();
	private static int path_index = 0;
	//private static int s2ucost = 0;
	//private static int s2uvalue = 0;
	private static int optimalScenicValue = 0 - Integer.MAX_VALUE;
	private static int pathCounter = 0;
	private Http http = new Http();
	private FindTDSP findTDSP = new FindTDSP();
	private ArrayList<Integer> maxValueVertex = new ArrayList<Integer>();
	//private Set<Integer> withinBudgetVertex = new HashSet<Integer>();
	//private Map<Integer,Pair<Integer,Integer>> withinBudgetVertex = new HashMap<Integer,Pair<Integer,Integer>>(); //V'
	private static PrintWriter outputWriter;
	private Map<Integer, Integer> SPcosts_candV2Target = new HashMap<Integer, Integer>();
	
	
	
	
	
	private Map.Entry<Integer, Integer> getEarliestArriveEntry(Map<Integer,Integer> map){
		  Map.Entry<Integer, Integer> minEA = null;
		  for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
		      if (minEA == null || minEA.getValue() > entry.getValue()) {
		    	  minEA = entry;
		      }
		  }
		  return minEA;
	  }
	  
	  
	  private Map.Entry<Integer, Integer> getLatestDepartureEntry(Map<Integer,Integer> map){
		  Map.Entry<Integer, Integer> maxLD = null;
		  for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
		      if (maxLD == null || maxLD.getValue() < entry.getValue()) {
		    	  maxLD = entry;
		      }
		  }
		  return maxLD;
	  }
	  
	  
	  public void calculateCandidateArcSet()throws Exception{
		  Map<Integer,Integer> FWR_result = FWR(QuerySetting.SourceVexID, GreedLS.Idx2TimeCost(QuerySetting.startTime), QuerySetting.budgetTime);
		  Map<Integer,Integer> BWR_result = BWR(QuerySetting.TargetVexID, GreedLS.Idx2TimeCost(QuerySetting.startTime), QuerySetting.budgetTime);
		  if(this.SPcosts_candV2Target!=null) this.SPcosts_candV2Target.clear();
		  
		  //calculate the intersection vertices
		  Gap g = new Gap();
		  for(Map.Entry<Integer, Integer> entryf : FWR_result.entrySet()){
			  if(BWR_result.containsKey(entryf.getKey())){
				  int ld = BWR_result.get(entryf.getKey());
				  if(entryf.getValue() <= ld){
					  //this.withinBudgetVertex.add(entryf.getKey());
					  //g = http.sendGet(GreedLS.graph.vertices.get(entryf.getKey()), GreedLS.graph.vertices.get(QuerySetting.TargetVexID), QuerySetting.startTime);
					  //System.out.println(entryf.getKey());
					  g = findTDSP.tdsp(entryf.getKey(), QuerySetting.TargetVexID, GreedLS.Idx2TimeCost(QuerySetting.startTime));
					  this.SPcosts_candV2Target.put(entryf.getKey(), g.SPCost);
					  //System.out.print(entryf.getKey() + "(" + entryf.getValue() + "," + ld + "), ");
				  }
			  }
		  }
	  }
	  
	
	/**
	 * calculate the earliest arrive time for each candidate arc
	 * 
	 * @param CAQ: candidate arc queue
	 * @param v0: starting vertex
	 * @param t0: starting time
	 * @param b: budget
	 */
	  public Map<Integer,Integer> FWR(int vid0, int t0, int b) throws Exception{
		  //Comparator<Map.Entry<Integer,Integer>> EAcomparator = new earliestArriveComparator();
		  //PriorityQueue<Pair<Integer,Double>> Q = new PriorityQueue<Pair<Integer,Double>>(1, EAcomparator);
		  Map<Integer,Integer> Q = new HashMap<Integer,Integer>();
		  Map<Integer,Integer> result = new HashMap<Integer,Integer>();
		  Q.put(vid0,  t0);
		  result.put(vid0, t0);
		  while(!Q.isEmpty()){
			  Map.Entry<Integer, Integer> entryEA = getEarliestArriveEntry(Q);
			  int vi = entryEA.getKey();
			  int eai = entryEA.getValue();
			  Q.remove(vi, eai);
			  //List<Pair<Integer, List<Pair<Integer,Integer>>>> vjList = GreedLS.graph.adjList.adjacencyList.get(vi);
			  if(GreedLS.graph.adjList.adjacencyList.containsKey(vi)){
				  for(Map.Entry<Integer, List<Pair<Integer,Integer>>> vjpair : GreedLS.graph.adjList.adjacencyList.get(vi).entrySet()){
					  if(vjpair.getKey()==349535){
						  int ying = 0;
					  }
					  //if(this.withinBudgetVertex.containsKey(vjpair.getKey())){ //----reduce the search space, search from V''
						  int eaj = eai + (vjpair.getValue()).get(GreedLS.TimeCost2Idx(eai)).getLeft();
						  //int eaj = eai + (vjpair.getValue()).get(1).getLeft(); //--static
						  if(eaj < t0+b){//----within the budget
							  double vj_target_dist = this.EarthDistance(GreedLS.graph.vertices.get(QuerySetting.TargetVexID).lat, GreedLS.graph.vertices.get(QuerySetting.TargetVexID).lng, GreedLS.graph.vertices.get(vjpair.getKey()).lat, GreedLS.graph.vertices.get(vjpair.getKey()).lng);
							  if(eaj+vj_target_dist*GreedLS.speedMIN < t0+b){//----A* pruning
								  if(!result.containsKey(vjpair.getKey())){
									  result.put(vjpair.getKey(), eaj);
									  if(!Q.containsKey(vjpair.getKey())) Q.put(vjpair.getKey(), eaj);
									  else{
										  int old_eaj = Q.get(vjpair.getKey());
										  if(old_eaj>eaj) Q.replace(vjpair.getKey(), eaj);
									  }
									  //--
									  /*if(result.size()%10000==0) {
										  System.out.print(result.size() * 100/496821 + "%...");
									  }*/
								  }
								  else{
									  int old_eaj = result.get(vjpair.getKey());
									  if(old_eaj > eaj){
										  result.replace(vjpair.getKey(), old_eaj, eaj);
										  if(Q.containsKey(vjpair.getKey())){
											  Q.replace(vjpair.getKey(), eaj);
										  }
									  }
								  }
								  //--print Q
								  /*for(Map.Entry<Integer,Integer> entryQ : Q.entrySet()){
									  System.out.print(entryQ.getKey() + ": " + entryQ.getValue() + ";  ");
								  }
								  System.out.println();*/
							  } //----A* pruning
						  }
							  
					  //}
				  }
			  }
			  
		  }//end while
		  return result;
	  }
	  
	  
	  
	  
	  
	  /**
	   * calculate the latest leaving time for each candidate arc
	   * 
	   * @param CAQ: candidate arc queue
	   * @param v0: starting vertex
	   * @param t0: starting time
	   * @param b: budget
	   */
	  public Map<Integer,Integer> BWR(int vidN, int t0, int b) throws Exception{
		  //Comparator<Map.Entry<Integer,Integer>> LDcomparator = new latestDepartureComparator();
		  Map<Integer,Integer> Q = new HashMap<Integer,Integer>();
		  Map<Integer,Integer> result = new HashMap<Integer,Integer>();
		  int tN = t0 + b;
		  Q.put(vidN,  tN);
		  result.put(vidN, t0+b);
		  while(!Q.isEmpty()){
			  Map.Entry<Integer, Integer> entryLD = getLatestDepartureEntry(Q);
			  int vj = entryLD.getKey();
			  int ldj = entryLD.getValue();
			  Q.remove(vj, ldj);
			  if(GreedLS.graph.adjList.reverse_adjacencyList.containsKey(vj)){
				  for(Map.Entry<Integer, List<Pair<Integer,Integer>>> vipair : GreedLS.graph.adjList.reverse_adjacencyList.get(vj).entrySet()){ //reverse adjacency list
					  int vi = vipair.getKey();
					  //if(this.withinBudgetVertex.containsKey(vi)){ //---reduce the search space, search from V''
						//--to find maximum time Taok of the list L=vipair.getRight() such that L[TimeCost2Inx(Taok)]+Taok <= ldj, and then ldi=ldj-L[Taok]
						  int Taok = ldj;
						  for(; Taok+ vipair.getValue().get(GreedLS.TimeCost2Idx(Taok)).getLeft()>ldj; Taok=Taok-1000); //minus 1 second
						  int ldi = ldj - vipair.getValue().get(GreedLS.TimeCost2Idx(Taok)).getLeft(); //to check here
						  //int ldi = ldj - vipair.getValue().get(1).getLeft(); //--static

						  if(ldi > t0){ //---within the budget
							  double source_vi_dist = this.EarthDistance(GreedLS.graph.vertices.get(QuerySetting.SourceVexID).lat, GreedLS.graph.vertices.get(QuerySetting.SourceVexID).lng, GreedLS.graph.vertices.get(vi).lat, GreedLS.graph.vertices.get(vi).lng);
							  if(ldi - source_vi_dist*GreedLS.speedMIN > t0){//---A* pruning
								  if(!result.containsKey(vipair.getKey())){
									  result.put(vipair.getKey(), ldi);
									  if(!Q.containsKey(vipair.getKey())) Q.put(vipair.getKey(), ldi);
									  else{
										  int old_ldi = result.get(vipair.getKey());
										  if(old_ldi < ldi) Q.replace(vipair.getKey(), ldi);
									  }
								  }
								  else{
									  int old_ldi = result.get(vipair.getKey());
									  if(old_ldi < ldi){
										  result.replace(vipair.getKey(), old_ldi, ldi);
										  if(Q.containsKey(vipair.getKey())){
											  Q.replace(vipair.getKey(), ldi);
										  }
									  }
								  }
							  }//---A* pruning
							  
						  }//---within the budget
					  //}
				  }
			  }
			  
		  }//end while
		  return result;
	  }
	  
	
	// Prints all paths from 's' to 'd'
	public void printAllPaths(int s, int d) throws Exception
	{
	    // Mark all the vertices as not visited
		/*for(int vi=0; vi<GreedLS.graph.vertices.size(); vi++){
			this.visited.add(false);
		}*/
		
		/*for(int vi=0; vi<GreedLS.graph.vertices.size(); vi++){
			this.maxValueVertex.add(0);
			
			Gap s_vi = http.sendGet(GreedLS.graph.vertices.get(QuerySetting.SourceVexID), GreedLS.graph.vertices.get(vi), QuerySetting.startTime);
			int nextTimeIdx = GreedLS.TimeCost2Idx(GreedLS.Idx2TimeCost(QuerySetting.startTime) + s_vi.SPCost);
			Gap vi_t = http.sendGet(GreedLS.graph.vertices.get(vi), GreedLS.graph.vertices.get(QuerySetting.TargetVexID), nextTimeIdx);
			if(s_vi.SPCost+vi_t.SPCost < QuerySetting.budgetTime){
				this.withinBudgetVertex.add(vi);
			}
		}*/
		
		//FileWriter fw = new FileWriter("/home/geocrowd/ying_scenicPath/result/opt_output.txt", true);
		FileWriter fw = new FileWriter("C:/YingLu/PhD research/Scenic path/TDexp/results/opt_output.txt", true);
        BufferedWriter bw = new BufferedWriter(fw);
		GraphFindAllPaths.outputWriter = new PrintWriter(bw);
		
		
		Gap sp = new Gap();
		//sp = http.sendGet(GreedLS.graph.vertices.get(QuerySetting.SourceVexID), GreedLS.graph.vertices.get(QuerySetting.TargetVexID), QuerySetting.startTime);
		sp = findTDSP.tdsp(QuerySetting.SourceVexID, QuerySetting.TargetVexID, GreedLS.Idx2TimeCost(QuerySetting.startTime));
		System.out.println("SPCost: " + sp.SPCost + "\tSPValue: " + sp.collectedValue);
		
		
		this.calculateCandidateArcSet();
		System.out.println("withinBudgetVertex number: " + this.SPcosts_candV2Target.size());
		
		
	 
	    // Call the recursive helper function to print all paths
		Set<Pair<Integer,Integer>> visited = new HashSet<Pair<Integer,Integer>>();
	    this.printAllPathsUtil(s, s, 0, 0);
	    System.out.println("finish searching");
	    if(GraphFindAllPaths.optimalScenicValue > 0)
	    	System.out.println("optimalScenicValue: " + GraphFindAllPaths.optimalScenicValue);
	    else System.out.println("no path is found.");
	}
	
	
	/*public void printSolution(List<Gap> gapList){
		  //System.out.print("solution: total value: " + this.solution.totalValue + "\ttotal cost: " + this.solution.totalCost);
		  for(Gap gap : gapList){ //---print the path of the solution
			  System.out.print(", " + gap.start + " --- " + gap.end);
		  }
		  System.out.println();
	  }*/
	
	
	public double EarthDistance(double plat, double plng, double qlat, double qlng) //earth distance between two points degree(-90,90) (-180, 180)
	{
		double PI = 3.1415926;
		double distpq = 6371 * 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((plat - qlat)*PI / 180 / 2), 2) + Math.cos(plat*PI / 180) * Math.cos(qlat*PI / 180) *Math.pow(Math.sin((plng - qlng)*PI / 180 / 2), 2)));
		distpq = distpq * 1000; //kilometers --> meters
		return distpq;
	}
	
	
	
	// A recursive function to print all paths from 'u' to 'd'.
	// visited[] keeps track of vertices in current path.
	// path[] stores actual vertices and path_index is current
	// index in path[]
	//s2ucost/s2uvalue -- the cost/value of the path (in this.path) from source s to the vertex u 
	/*int value = 0;
	int cost = 0;
	int time = GreedLS.Idx2TimeCost(QuerySetting.startTime);
	for (int i = 0; i<path_index-1; i++){
		List<Pair<Integer,Integer>> cost_value_list = GreedLS.graph.adjList.adjacencyList.get(this.path.get(i)).get(this.path.get(i+1));
		  	int idx_vm = GreedLS.TimeCost2Idx(time);
		  	time += cost_value_list.get(idx_vm).getLeft();
		  	value += cost_value_list.get(idx_vm).getRight();
		  	cost += cost_value_list.get(idx_vm).getLeft();
	}*/
	public Pair<Integer, Integer> printAllPathsUtil(int preu, int u, int s2ucost, int s2uvalue) throws Exception
	{
	    // Mark the current node and store it in path[]
	    //this.visited.set(u, true);
	    this.path.add(path_index, u);
	    path_index++;
	    
	    
	 
	    // If current vertex is same as destination, then print
	    // current path[]
	    if (u == QuerySetting.TargetVexID)
	    {
	    	/*int value = 0;
	    	int cost = 0;
	    	int time = GreedLS.Idx2TimeCost(QuerySetting.startTime);
	    	for (int i = 0; i<path_index-1; i++){
	    		List<Pair<Integer,Integer>> cost_value_list = GreedLS.graph.adjList.adjacencyList.get(this.path.get(i)).get(this.path.get(i+1));
	    		  	int idx_vm = GreedLS.TimeCost2Idx(time);
	    		  	time += cost_value_list.get(idx_vm).getLeft();
	    		  	value += cost_value_list.get(idx_vm).getRight();
	    		  	cost += cost_value_list.get(idx_vm).getLeft();
	    	}*/
	    	if(s2ucost<=QuerySetting.budgetTime){
	    		if(s2uvalue > GraphFindAllPaths.optimalScenicValue){
	    			GraphFindAllPaths.optimalScenicValue = s2uvalue;
	    			
	    			GraphFindAllPaths.pathCounter++;
		    		System.out.println();
			    	System.out.print("path#: " + GraphFindAllPaths.pathCounter + "\tcost: " + s2ucost + "\tvalue: " + s2uvalue + "\tcurrent optimalValue: " + GraphFindAllPaths.optimalScenicValue + "\t");
	    			for(int j=0; j<path_index; j++){
	    				System.out.print(this.path.get(j)+";");
	    			}
			    	//GraphFindAllPaths.outputWriter.println();
	    			//GraphFindAllPaths.outputWriter.print("path#: " + GraphFindAllPaths.pathCounter + "\tvalue: " + value + "\tcurrent optimalValue: " + GraphFindAllPaths.optimalScenicValue);
	    			//GraphFindAllPaths.outputWriter.flush();
	    		}
	    	}
	    	//else {System.out.println("find a reachable path but beyond the budget..");}
	    }
	    else // If current vertex is not destination
	    {
	    	int uvcost = 0;
	    	int uvvalue = 0;
	        // Recur for all the vertices adjacent to current vertex
	    	for(Map.Entry<Integer, List<Pair<Integer,Integer>>> vpair : GreedLS.graph.adjList.adjacencyList.get(u).entrySet()){
	    		
	    		//if(this.visited.contains(new Pair<Integer,Integer>(u, vpair.getKey())) == false){ //------unvisited
	    		Boolean inPath = false;
	    		for (int i = 0; i<path_index-1; i++){
	    			int pathu = this.path.get(i);
	    			int pathv = this.path.get(i+1);
	    			if(pathu==u && pathv==vpair.getKey()) {
	    				inPath = true; break;
	    				}
	    		}
	    		if(inPath == false && this.SPcosts_candV2Target.containsKey(vpair.getKey()) && !preuVisited.contains(vpair.getKey())){//
	    			//------within the budget
	    			/*int value = 0;
	    			int cost = 0;
	    			int time = GreedLS.Idx2TimeCost(QuerySetting.startTime);
	    			for (int i = 0; i<path_index-1; i++){
	    				List<Pair<Integer,Integer>> cost_value_list = GreedLS.graph.adjList.adjacencyList.get(this.path.get(i)).get(this.path.get(i+1));
	    				  	int idx_vm = GreedLS.TimeCost2Idx(time);
	    				  	time += cost_value_list.get(idx_vm).getLeft();
	    				  	value += cost_value_list.get(idx_vm).getRight();
	    				  	cost += cost_value_list.get(idx_vm).getLeft();
	    			}*/
			    	//--------
			    	List<Pair<Integer,Integer>> cost_value_list = GreedLS.graph.adjList.adjacencyList.get(u).get(vpair.getKey());
		  		  	int idx_vm = GreedLS.TimeCost2Idx(GreedLS.Idx2TimeCost(QuerySetting.startTime)+s2ucost);
		  		  	//cost += cost_value_list.get(idx_vm).getLeft();
		  		  	//value += cost_value_list.get(idx_vm).getRight();
		  		  	
		  		  	uvcost = cost_value_list.get(idx_vm).getLeft();
		  		  	uvvalue = cost_value_list.get(idx_vm).getRight();
		  		  	//System.out.println(cost + " -- " + ying);
			    	//---------
		    		double v_target_dist = this.EarthDistance(GreedLS.graph.vertices.get(QuerySetting.TargetVexID).lat, GreedLS.graph.vertices.get(QuerySetting.TargetVexID).lng, GreedLS.graph.vertices.get(vpair.getKey()).lat, GreedLS.graph.vertices.get(vpair.getKey()).lng);
		    		//Gap v_target = new Gap();
			    	//v_target = http.sendGet(GreedLS.graph.vertices.get(vpair.getKey()), GreedLS.graph.vertices.get(QuerySetting.TargetVexID), GreedLS.TimeCost2Idx(time));
					 //System.out.println("v_target.SPCost: " + v_target.SPCost);
		    		//if(s2ucost + v_target_dist*GreedLS.speedMIN < QuerySetting.budgetTime){//A*- filtering
		  		  	int v2tcost = this.SPcosts_candV2Target.get(vpair.getKey());
			    	//if(s2ucost + uvcost + v2tcost < QuerySetting.budgetTime){//A*- filtering
					if(s2ucost + uvcost + v2tcost < QuerySetting.budgetTime && s2ucost + uvcost + v_target_dist*GreedLS.speedMIN <= QuerySetting.budgetTime){//A*- filtering  
		    			Pair<Integer, Integer> new_cost_value = this.printAllPathsUtil(u, vpair.getKey(), s2ucost+uvcost, s2uvalue+uvvalue, preuVisited);
		    			s2ucost = new_cost_value.getLeft();
		    			s2uvalue = new_cost_value.getRight();
		    		}
	    		}
	    		uVisited.add(vpair.getKey());
	    	}
	    }
	    
	    // Remove current vertex from path[] and mark it as unvisited
	    GraphFindAllPaths.path_index = GraphFindAllPaths.path_index - 1;
	    if(GreedLS.graph.adjList.adjacencyList.get(preu)!=null && GreedLS.graph.adjList.adjacencyList.get(preu).get(u)!=null){
	    	int minuscost = GreedLS.graph.adjList.adjacencyList.get(preu).get(u).get(GreedLS.TimeCost2Idx(GreedLS.Idx2TimeCost(QuerySetting.startTime)+s2ucost)).getLeft();
	    	s2ucost = s2ucost - minuscost;//minus cost from preu to u
		    int minusvalue = GreedLS.graph.adjList.adjacencyList.get(preu).get(u).get(GreedLS.TimeCost2Idx(GreedLS.Idx2TimeCost(QuerySetting.startTime)+s2ucost)).getRight();
	    	s2uvalue = s2uvalue - minusvalue;//minus value from preu to u
		    //System.out.println("can find preu to u: " + preu + ", " + u);
	    	
	    	/*Pair visitArc = new Pair<Integer,Integer>(preu, u);
    		if(!visited.contains(visitArc)){
    			visited.add(visitArc);
    		}*/
	    }
	    else{System.out.println("cannot find preu to u: " + preu + ", " + u);}
	    
	    Pair<Integer, Integer> ret_cost_value = new Pair<Integer, Integer>(s2ucost, s2uvalue);
	    return ret_cost_value;
	   }
	
	
	
	
}





